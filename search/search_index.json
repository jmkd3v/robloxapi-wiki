{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Home \u00b6 Documenting the internals of the Roblox API, one article at a time. Welcome \u00b6 This is the wiki for the RoAPI community. RoAPI is a community dedicated to using and making discoveries with the Roblox API. On this wiki, you'll find a number of articles about the niche and somewhat hidden parts of the Roblox API. Get started \u00b6 Want to build something cool? Learn everything you need to know about the API in the Tutorial !","title":"Home"},{"location":"#home","text":"Documenting the internals of the Roblox API, one article at a time.","title":"Home"},{"location":"#welcome","text":"This is the wiki for the RoAPI community. RoAPI is a community dedicated to using and making discoveries with the Roblox API. On this wiki, you'll find a number of articles about the niche and somewhat hidden parts of the Roblox API.","title":"Welcome"},{"location":"#get-started","text":"Want to build something cool? Learn everything you need to know about the API in the Tutorial !","title":"Get started"},{"location":"cdn-hashes/","text":"CDN hashes \u00b6 Some endpoints, like the imageUrl provided by thumbnails.roblox.com/v1/users/avatar-3d?userId=1 , don't provide a full CDN URL and only provide raw hashes, like this: bbdb80c2b573bf222da3e92f5f148330 . We need to turn this into a full CDN URL. A CDN URL looks like t[X].rbxcdn.com/bbdb80c2b573bf222da3e92f5f148330 where X is the CDN number. The CDN number ranges from 0 to 7, so you might be tempted to send a request to t0, then t1, and keep going until you reach the one containing the object. This works, but it's quite wasteful as you send up to 8 requests for one object. https:// t c X .rbxcdn.com/ const hashInput = document.getElementById(\"hash-calculator-input\") const hashNum = document.getElementById(\"hash-calculator-num\") const hashCdnSelector = document.getElementById(\"hash-calculator-select\") const hashCopyButton = document.getElementById(\"hash-calculator-copy-button\") const getCdnUrl = (cdnType, hash) => { const t = [...hash].reduce((lastCode, char) => lastCode ^ char.charCodeAt(0), 31) return `https://${cdnType}${t % 8}.rbxcdn.com/${hash}`; } const update = () => { const hash = hashInput.value const hashNumValue = ([...hash].reduce((lastCode, char) => lastCode ^ char.charCodeAt(0), 31)) % 8 hashNum.textContent = hashNumValue hashCopyButton.setAttribute(\"data-clipboard-text\", getCdnUrl(hashCdnSelector.value, hash)) } update(); hashInput.addEventListener(\"input\", update); A common implementation is as follows: Create a function that takes in a string hash . In this function, define x to 31 . Next, we loop through the first 32 characters in hash , and in each iteration set the x variable to itself bitwise XORed against the integer representation of that character ( x ^= chr ). Then we return x . We can then use the x variable to compose the final URL with the pattern https://t{x}.rbxcdn.com/{hash} . Here are some test cases for this function: func(\"bbdb80c2b573bf222da3e92f5f148330\") -> 5 func(\"139602eb7c640c43833470e07caada4a\") -> 7 func(\"b717c50234c3d91b0be7dbfc9c588ed4\") -> 0 Examples \u00b6 Python Golang Elixir 64 bit NASM Assembly JavaScript C# Ruby C++ C Rust Lua 5.3 Lua 5.2/Luau Java Kotlin Crystal F# PowerShell def get_cdn_url ( hash ): i = 31 for char in hash [: 32 ]: i ^= ord ( char ) # i ^= int(char, 16) also works return f \"https://t { i % 8 } .rbxcdn.com/ { hash } \" # alternatively: from functools import reduce def get_cdn_url ( hash ): t = reduce ( lambda last_code , char : last_code ^ ord ( char ), hash , 31 ) return f \"https://t { t % 8 } .rbxcdn.com/ { hash } \" package pkg import \"fmt\" // GetCdnUrl func GetCdnUrl ( hash string ) string { if hash == \"\" { panic ( \"hash is empty\" ) } var i int = 31 for _ , char := range hash { i = i ^ int ( char ) } return fmt . Sprintf ( \"https://t%d.rbxcdn.com/%s\" , i % 8 , hash ) } defmodule CDN do @spec get_cdn_url ( String . t ()) :: String . t () def get_cdn_url ( hash ) do t = hash |> String . to_charlist |> Enum . reduce ( 31 , fn char , last_code -> Bitwise . bxor ( last_code , char ) end ) \"https://t #{ rem ( t , 8 ) } .rbxcdn.com/ #{ hash } \" end end ; nasm -felf64 cdn_hash.asm -o cdn_hash.o ; gcc -m64 -o cdn_hash cdn_hash.o -no-pie ; ./cdn_hash extern printf , snprintf section .text global main get_cdn_url: push rdi push rsi push rdx push rcx push r8 push rax ; rdi is the accumulator mov rdi , 31 jmp .is_at_end .xor_t: push rax ; rax is 8 bytes, get the first byte by AND'ing it by 255 mov rax , [ rax ] and rax , 0xFF xor rdi , rax pop rax ; increment hash pointer inc rax .is_at_end: cmp byte [ rax ], 0 jne .xor_t .fmt_cdn_url: mov rax , rdi xor rdx , rdx mov rsi , 8 div rsi ; t mov rcx , rdx ; buffer lea rdi , [ cdn_url ] ; buffer size mov rsi , 55 ; format lea rdx , [ url_fmt ] ; hash pop rax mov r8 , rax push rax xor rax , rax call snprintf pop rax pop r8 pop rcx pop rdx pop rsi pop rdi ret main: lea rax , [ hash ] call get_cdn_url lea rdi , [ s_fmt ] lea rsi , [ cdn_url ] xor rax , rax call printf mov rax , 60 mov rdi , 0 syscall section .data cdn_url: times 55 db 0 s_fmt: db \"%s\" , 10 , 0 url_fmt: db \"https://t%d.rbxcdn.com/%s\" , 0 hash: db \"bbdb80c2b573bf222da3e92f5f148330\" , 0 const getCdnUrl = ( hash ) => { const t = [... hash ]. reduce (( lastCode , char ) => lastCode ^ char . charCodeAt ( 0 ), 31 ) return `https://t ${ t % 8 } .rbxcdn.com/ ${ hash } ` ; } using System ; using System.Linq ; string GetCdnUrl ( string hash ) { int t = hash . ToCharArray (). Aggregate ( 31 , ( lastCode , character ) => lastCode ^ ( int ) character ); return $\"https://t{t % 8}.rbxcdn.com/{hash}\" ; } def get_cdn_url ( hash ) t = hash . codepoints . reduce ( 31 ) { | last_code , code | last_code ^ code } \"https://t #{ t % 8 } .rbxcdn.com/ #{ hash } \" end std :: string getCdnUrl ( const std :: string & hash ) { if ( hash . empty ()) throw std :: exception ( \"Hash cannot be empty\" ); int i = 31 ; for ( char const & c : hash ) { i ^= ( int ) c ; } char buff [ 100 ]; snprintf ( buff , sizeof ( buff ), \"https://t%d.rbxcdn.com/%s\" , i % 8 , hash . c_str ()); return std :: string ( buff ); } void getCdnUrl ( char * hash , char * buffer ) { int i = 31 ; int hashLength = strlen ( hash ); for ( int j = 0 ; j < hashLength ; j ++ ) { i ^= ( int ) hash [ j ]; } snprintf ( buffer , 55 , \"https://t%d.rbxcdn.com/%s\" , i % 8 , hash ); } fn get_cdn_url ( hash : & str ) -> String { let t = hash . as_bytes (). iter (). fold ( 31 , | last_code , code | { last_code ^ code }); format! ( \"https://t{}.rbxcdn.com/{}\" , t % 8 , hash ) } local function getCdnUrl ( hash ) local i = 31 for _ , code in utf8.codes ( hash ) do i = i ~ code end return string.format ( \"https://t%d.rbxcdn.com/%s\" , i % 8 , hash ) end local function getCdnUrl ( hash ) local i = 31 for _ , code in utf8.codes ( hash ) do i = bit32.bxor ( i , code ) end return string.format ( \"https://t%d.rbxcdn.com/%s\" , i % 8 , hash ) end String getCdnUrl ( String hash ) { int i = 31 ; for ( char character : hash . toCharArray ()) { i ^= ( int ) character ; } return String . format ( \"https://t%d.rbxcdn.com/%s\" , i % 8 , hash ); } fun getCdnUrl ( hash : String ): String { var i = 31 hash . forEach ({ character : Char -> i = i xor character . toInt () }); return \"https://t ${ i % 8 } .rbxcdn.com/ ${ hash } \" } def get_cdn_url ( hash : String ): String t = hash . codepoints . reduce ( 31 ) { | last_code , code | last_code ^ code } \"https://t #{ t % 8 } .rbxcdn.com/ #{ hash } \" end let getCdnUrl ( hash : string ) = let t = hash |> Seq . fold ( fun lastCode char -> lastCode ^^^ ( int ) char ) 31 $ \"https://t{t % 8}.rbxcdn.com/{hash}\" function get-cdn -url { param ( [string] $hash ) if ( [string] :: IsNullOrEmpty ( $hash )) { throw [System.ArgumentNullException] :: new ( \"hash\" ); } [int] $i = 31 ; foreach ( $c in $hash . ToCharArray ()) { $i = $i -bxor $c ; } return \"https://t $( $i % 8 ) .rbxcdn.com/ $( $hash ) \" }","title":"CDN hashes"},{"location":"cdn-hashes/#cdn-hashes","text":"Some endpoints, like the imageUrl provided by thumbnails.roblox.com/v1/users/avatar-3d?userId=1 , don't provide a full CDN URL and only provide raw hashes, like this: bbdb80c2b573bf222da3e92f5f148330 . We need to turn this into a full CDN URL. A CDN URL looks like t[X].rbxcdn.com/bbdb80c2b573bf222da3e92f5f148330 where X is the CDN number. The CDN number ranges from 0 to 7, so you might be tempted to send a request to t0, then t1, and keep going until you reach the one containing the object. This works, but it's quite wasteful as you send up to 8 requests for one object. https:// t c X .rbxcdn.com/ const hashInput = document.getElementById(\"hash-calculator-input\") const hashNum = document.getElementById(\"hash-calculator-num\") const hashCdnSelector = document.getElementById(\"hash-calculator-select\") const hashCopyButton = document.getElementById(\"hash-calculator-copy-button\") const getCdnUrl = (cdnType, hash) => { const t = [...hash].reduce((lastCode, char) => lastCode ^ char.charCodeAt(0), 31) return `https://${cdnType}${t % 8}.rbxcdn.com/${hash}`; } const update = () => { const hash = hashInput.value const hashNumValue = ([...hash].reduce((lastCode, char) => lastCode ^ char.charCodeAt(0), 31)) % 8 hashNum.textContent = hashNumValue hashCopyButton.setAttribute(\"data-clipboard-text\", getCdnUrl(hashCdnSelector.value, hash)) } update(); hashInput.addEventListener(\"input\", update); A common implementation is as follows: Create a function that takes in a string hash . In this function, define x to 31 . Next, we loop through the first 32 characters in hash , and in each iteration set the x variable to itself bitwise XORed against the integer representation of that character ( x ^= chr ). Then we return x . We can then use the x variable to compose the final URL with the pattern https://t{x}.rbxcdn.com/{hash} . Here are some test cases for this function: func(\"bbdb80c2b573bf222da3e92f5f148330\") -> 5 func(\"139602eb7c640c43833470e07caada4a\") -> 7 func(\"b717c50234c3d91b0be7dbfc9c588ed4\") -> 0","title":"CDN hashes"},{"location":"cdn-hashes/#examples","text":"Python Golang Elixir 64 bit NASM Assembly JavaScript C# Ruby C++ C Rust Lua 5.3 Lua 5.2/Luau Java Kotlin Crystal F# PowerShell def get_cdn_url ( hash ): i = 31 for char in hash [: 32 ]: i ^= ord ( char ) # i ^= int(char, 16) also works return f \"https://t { i % 8 } .rbxcdn.com/ { hash } \" # alternatively: from functools import reduce def get_cdn_url ( hash ): t = reduce ( lambda last_code , char : last_code ^ ord ( char ), hash , 31 ) return f \"https://t { t % 8 } .rbxcdn.com/ { hash } \" package pkg import \"fmt\" // GetCdnUrl func GetCdnUrl ( hash string ) string { if hash == \"\" { panic ( \"hash is empty\" ) } var i int = 31 for _ , char := range hash { i = i ^ int ( char ) } return fmt . Sprintf ( \"https://t%d.rbxcdn.com/%s\" , i % 8 , hash ) } defmodule CDN do @spec get_cdn_url ( String . t ()) :: String . t () def get_cdn_url ( hash ) do t = hash |> String . to_charlist |> Enum . reduce ( 31 , fn char , last_code -> Bitwise . bxor ( last_code , char ) end ) \"https://t #{ rem ( t , 8 ) } .rbxcdn.com/ #{ hash } \" end end ; nasm -felf64 cdn_hash.asm -o cdn_hash.o ; gcc -m64 -o cdn_hash cdn_hash.o -no-pie ; ./cdn_hash extern printf , snprintf section .text global main get_cdn_url: push rdi push rsi push rdx push rcx push r8 push rax ; rdi is the accumulator mov rdi , 31 jmp .is_at_end .xor_t: push rax ; rax is 8 bytes, get the first byte by AND'ing it by 255 mov rax , [ rax ] and rax , 0xFF xor rdi , rax pop rax ; increment hash pointer inc rax .is_at_end: cmp byte [ rax ], 0 jne .xor_t .fmt_cdn_url: mov rax , rdi xor rdx , rdx mov rsi , 8 div rsi ; t mov rcx , rdx ; buffer lea rdi , [ cdn_url ] ; buffer size mov rsi , 55 ; format lea rdx , [ url_fmt ] ; hash pop rax mov r8 , rax push rax xor rax , rax call snprintf pop rax pop r8 pop rcx pop rdx pop rsi pop rdi ret main: lea rax , [ hash ] call get_cdn_url lea rdi , [ s_fmt ] lea rsi , [ cdn_url ] xor rax , rax call printf mov rax , 60 mov rdi , 0 syscall section .data cdn_url: times 55 db 0 s_fmt: db \"%s\" , 10 , 0 url_fmt: db \"https://t%d.rbxcdn.com/%s\" , 0 hash: db \"bbdb80c2b573bf222da3e92f5f148330\" , 0 const getCdnUrl = ( hash ) => { const t = [... hash ]. reduce (( lastCode , char ) => lastCode ^ char . charCodeAt ( 0 ), 31 ) return `https://t ${ t % 8 } .rbxcdn.com/ ${ hash } ` ; } using System ; using System.Linq ; string GetCdnUrl ( string hash ) { int t = hash . ToCharArray (). Aggregate ( 31 , ( lastCode , character ) => lastCode ^ ( int ) character ); return $\"https://t{t % 8}.rbxcdn.com/{hash}\" ; } def get_cdn_url ( hash ) t = hash . codepoints . reduce ( 31 ) { | last_code , code | last_code ^ code } \"https://t #{ t % 8 } .rbxcdn.com/ #{ hash } \" end std :: string getCdnUrl ( const std :: string & hash ) { if ( hash . empty ()) throw std :: exception ( \"Hash cannot be empty\" ); int i = 31 ; for ( char const & c : hash ) { i ^= ( int ) c ; } char buff [ 100 ]; snprintf ( buff , sizeof ( buff ), \"https://t%d.rbxcdn.com/%s\" , i % 8 , hash . c_str ()); return std :: string ( buff ); } void getCdnUrl ( char * hash , char * buffer ) { int i = 31 ; int hashLength = strlen ( hash ); for ( int j = 0 ; j < hashLength ; j ++ ) { i ^= ( int ) hash [ j ]; } snprintf ( buffer , 55 , \"https://t%d.rbxcdn.com/%s\" , i % 8 , hash ); } fn get_cdn_url ( hash : & str ) -> String { let t = hash . as_bytes (). iter (). fold ( 31 , | last_code , code | { last_code ^ code }); format! ( \"https://t{}.rbxcdn.com/{}\" , t % 8 , hash ) } local function getCdnUrl ( hash ) local i = 31 for _ , code in utf8.codes ( hash ) do i = i ~ code end return string.format ( \"https://t%d.rbxcdn.com/%s\" , i % 8 , hash ) end local function getCdnUrl ( hash ) local i = 31 for _ , code in utf8.codes ( hash ) do i = bit32.bxor ( i , code ) end return string.format ( \"https://t%d.rbxcdn.com/%s\" , i % 8 , hash ) end String getCdnUrl ( String hash ) { int i = 31 ; for ( char character : hash . toCharArray ()) { i ^= ( int ) character ; } return String . format ( \"https://t%d.rbxcdn.com/%s\" , i % 8 , hash ); } fun getCdnUrl ( hash : String ): String { var i = 31 hash . forEach ({ character : Char -> i = i xor character . toInt () }); return \"https://t ${ i % 8 } .rbxcdn.com/ ${ hash } \" } def get_cdn_url ( hash : String ): String t = hash . codepoints . reduce ( 31 ) { | last_code , code | last_code ^ code } \"https://t #{ t % 8 } .rbxcdn.com/ #{ hash } \" end let getCdnUrl ( hash : string ) = let t = hash |> Seq . fold ( fun lastCode char -> lastCode ^^^ ( int ) char ) 31 $ \"https://t{t % 8}.rbxcdn.com/{hash}\" function get-cdn -url { param ( [string] $hash ) if ( [string] :: IsNullOrEmpty ( $hash )) { throw [System.ArgumentNullException] :: new ( \"hash\" ); } [int] $i = 31 ; foreach ( $c in $hash . ToCharArray ()) { $i = $i -bxor $c ; } return \"https://t $( $i % 8 ) .rbxcdn.com/ $( $hash ) \" }","title":"Examples"},{"location":"game-templates/","text":"Game templates \u00b6 All information fetched from https://develop.roblox.com/v1/gametemplates . Downloads are from the Roblox official CDN. Downloads will not have an .rbxl extension, but they are rbxl files. /* only affect child of article so we don't break anything else (hack!) */ article th[align='right'] { min-width: 0 !important; } article td { vertical-align: middle !important; } article td img { border-radius: 4px; height: 64px !important; margin-right: 1em; } .table-flex-fix { display: flex; align-items: center; } Name Type Created Updated Racing Gameplay 02/12/2015 04/04/2019 Obby Gameplay 01/14/2015 04/05/2019 Line Runner Gameplay 09/28/2015 04/04/2019 Capture The Flag Gameplay 11/01/2013 04/04/2019 Team/FFA Arena Gameplay 09/28/2015 11/19/2019 Combat Gameplay 01/14/2015 11/19/2019 Baseplate Generic 11/01/2013 07/08/2019 Classic Baseplate Generic 03/23/2021 04/16/2021 Flat Terrain Generic 11/01/2013 07/08/2019 Move It Simulator Generic 07/15/2020 07/15/2020 Mansion of Wonder Generic 06/10/2021 06/10/2021 Concert Theme 07/18/2022 07/18/2022 Village Theme 10/10/2016 11/19/2019 Castle Theme 01/14/2015 04/04/2019 Suburban Theme 02/19/2016 06/20/2019 Pirate Island Theme 07/01/2015 04/05/2019 City Theme 01/14/2015 04/04/2019 Starting Place Theme 03/09/2016 04/05/2019","title":"Game templates"},{"location":"game-templates/#game-templates","text":"All information fetched from https://develop.roblox.com/v1/gametemplates . Downloads are from the Roblox official CDN. Downloads will not have an .rbxl extension, but they are rbxl files. /* only affect child of article so we don't break anything else (hack!) */ article th[align='right'] { min-width: 0 !important; } article td { vertical-align: middle !important; } article td img { border-radius: 4px; height: 64px !important; margin-right: 1em; } .table-flex-fix { display: flex; align-items: center; } Name Type Created Updated Racing Gameplay 02/12/2015 04/04/2019 Obby Gameplay 01/14/2015 04/05/2019 Line Runner Gameplay 09/28/2015 04/04/2019 Capture The Flag Gameplay 11/01/2013 04/04/2019 Team/FFA Arena Gameplay 09/28/2015 11/19/2019 Combat Gameplay 01/14/2015 11/19/2019 Baseplate Generic 11/01/2013 07/08/2019 Classic Baseplate Generic 03/23/2021 04/16/2021 Flat Terrain Generic 11/01/2013 07/08/2019 Move It Simulator Generic 07/15/2020 07/15/2020 Mansion of Wonder Generic 06/10/2021 06/10/2021 Concert Theme 07/18/2022 07/18/2022 Village Theme 10/10/2016 11/19/2019 Castle Theme 01/14/2015 04/04/2019 Suburban Theme 02/19/2016 06/20/2019 Pirate Island Theme 07/01/2015 04/05/2019 City Theme 01/14/2015 04/04/2019 Starting Place Theme 03/09/2016 04/05/2019","title":"Game templates"},{"location":"library-list/","text":"The Roblox API is powerful, but it can be frustrating to use without any help. Instead of sending requests on your own, consider using a Roblox API \"wrapper\" library. These libraries send requests for you and can help you create apps faster. If none of these libraries are your thing, continue to the Tutorial to learn how to send requests on your own. Name Language Links ro.py Python 3 Source Docs bloxy JavaScript Source Docs noblox.js JavaScript Source Docs dynablox_opencloud JavaScript Source Docs","title":"List of Roblox API wrapper libraries"},{"location":"tutorial/","text":"Get started \u00b6 Note This tutorial covers usage of Roblox's \"Backend Development V1\" APIs. If you're interested in Roblox's new Open Cloud system, see Roblox's official Open Cloud tutorial. The Roblox API is extremely powerful - it can be used to create anything from group ranking bots to game statistics websites. As a developer, there are two main ways you\u2019ll want to access the Roblox API: sending the requests yourself or using one of the multiple wrappers for your favorite programming language. In this tutorial, I\u2019ll go over both of these methods. To navigate this tutorial, use the navigation bar below to move forward and back through the pages. Have fun.","title":"Get started"},{"location":"tutorial/#get-started","text":"Note This tutorial covers usage of Roblox's \"Backend Development V1\" APIs. If you're interested in Roblox's new Open Cloud system, see Roblox's official Open Cloud tutorial. The Roblox API is extremely powerful - it can be used to create anything from group ranking bots to game statistics websites. As a developer, there are two main ways you\u2019ll want to access the Roblox API: sending the requests yourself or using one of the multiple wrappers for your favorite programming language. In this tutorial, I\u2019ll go over both of these methods. To navigate this tutorial, use the navigation bar below to move forward and back through the pages. Have fun.","title":"Get started"},{"location":"tutorial/finding-endpoints/","text":"Finding endpoints \u00b6 The first thing you\u2019ll need to know when accessing the API is what endpoint you\u2019ll need to do something. Try to stay away from endpoints on api.roblox.com or www.roblox.com - they are deprecated and there are almost always better alternatives on other subdomains. You should also keep track of the Official List of Deprecated Web Endpoints for updates on when endpoints are disabled. You can also access the documentation for an individual domain by appending /docs to the end of it ( users.roblox.com > users.roblox.com/docs ). You can find a list of these subdomains here . Some domains don\u2019t have documentation available, like realtime.roblox.com .","title":"Finding endpoints"},{"location":"tutorial/finding-endpoints/#finding-endpoints","text":"The first thing you\u2019ll need to know when accessing the API is what endpoint you\u2019ll need to do something. Try to stay away from endpoints on api.roblox.com or www.roblox.com - they are deprecated and there are almost always better alternatives on other subdomains. You should also keep track of the Official List of Deprecated Web Endpoints for updates on when endpoints are disabled. You can also access the documentation for an individual domain by appending /docs to the end of it ( users.roblox.com > users.roblox.com/docs ). You can find a list of these subdomains here . Some domains don\u2019t have documentation available, like realtime.roblox.com .","title":"Finding endpoints"},{"location":"tutorial/understanding-documentation/","text":"Understanding documentation \u00b6 Each documentation page contains a list of public endpoints available on that domain and lots of information about how to use them. This article will tell you how to understand this documentation. All requests \u00b6 Documentation for all types of requests will always contain the following: The text in top left corner and the background color differ depending on the method of the request, most often GET or POST. The Example Value contains an example of what the response from this endpoint might look like - this is useful when you want to build code that requests to an endpoint without sending a request to it yourself to figure out how it responds. The Response Content Type determines what should be passed to the Accept header - there\u2019s almost never any reason to change this. The Parameters change what data is passed to the endpoint when sending the request. The data is passed as a query string or as part of the URL for GET requests and is passed as a JSON body in almost all other requests. The Response Messages will explain what different HTTP Status Codes mean when returned from the server - if you\u2019re getting an error without enough information, you can check the response messages to see if that status code means something for that endpoint. The \"Try it out!\" button will send a request to this endpoint with the data supplied in the Parameters. This will be useful for testing out an endpoint without writing code to send requests. Requests with a body \u00b6 Requests with a body, like POST, PUT, PATCH, and DELETE, have extra data attached. As you can see, we\u2019ve got a parameter labeled request , which just refers to the body of the request, as you can see from the \"Parameter Type\" to the right of it. We also are able to change that data\u2019s content type - you\u2019ll almost always want to keep this on application/json given most endpoints accept JSON. You\u2019ll also see an \"Example Value\" - this shows you an example of data you can pass as the request body. Clicking on that Example Value will immediately set the body to the example data. This is useful for quickly testing an endpoint before implementing it into your program.","title":"Understanding documentation"},{"location":"tutorial/understanding-documentation/#understanding-documentation","text":"Each documentation page contains a list of public endpoints available on that domain and lots of information about how to use them. This article will tell you how to understand this documentation.","title":"Understanding documentation"},{"location":"tutorial/understanding-documentation/#all-requests","text":"Documentation for all types of requests will always contain the following: The text in top left corner and the background color differ depending on the method of the request, most often GET or POST. The Example Value contains an example of what the response from this endpoint might look like - this is useful when you want to build code that requests to an endpoint without sending a request to it yourself to figure out how it responds. The Response Content Type determines what should be passed to the Accept header - there\u2019s almost never any reason to change this. The Parameters change what data is passed to the endpoint when sending the request. The data is passed as a query string or as part of the URL for GET requests and is passed as a JSON body in almost all other requests. The Response Messages will explain what different HTTP Status Codes mean when returned from the server - if you\u2019re getting an error without enough information, you can check the response messages to see if that status code means something for that endpoint. The \"Try it out!\" button will send a request to this endpoint with the data supplied in the Parameters. This will be useful for testing out an endpoint without writing code to send requests.","title":"All requests"},{"location":"tutorial/understanding-documentation/#requests-with-a-body","text":"Requests with a body, like POST, PUT, PATCH, and DELETE, have extra data attached. As you can see, we\u2019ve got a parameter labeled request , which just refers to the body of the request, as you can see from the \"Parameter Type\" to the right of it. We also are able to change that data\u2019s content type - you\u2019ll almost always want to keep this on application/json given most endpoints accept JSON. You\u2019ll also see an \"Example Value\" - this shows you an example of data you can pass as the request body. Clicking on that Example Value will immediately set the body to the example data. This is useful for quickly testing an endpoint before implementing it into your program.","title":"Requests with a body"}]}