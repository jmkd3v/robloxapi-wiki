{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p>Documenting the internals of the Roblox API.</p>"},{"location":"#welcome","title":"Welcome","text":"<p>This is the wiki for the RoAPI community. RoAPI is a community dedicated to using and making discoveries with the Roblox API. On this wiki, you'll find a number of articles about the niche and somewhat hidden parts of the Roblox API.</p> <p>Learn everything you need to know about the API in the Tutorial!</p>"},{"location":"cdn-hashes/","title":"CDN hashes","text":"<p>Some endpoints, like the imageUrl provided by <code>thumbnails.roblox.com/v1/users/avatar-3d?userId=1</code>, don't provide a full CDN URL and only provide raw hashes, like this: <code>bbdb80c2b573bf222da3e92f5f148330</code>. We need to turn this into a full CDN URL.  A CDN URL looks like <code>t[X].rbxcdn.com/bbdb80c2b573bf222da3e92f5f148330</code> where X is the CDN number. The CDN number ranges from 0 to 7, so you might be tempted to send a request to t0, then t1, and keep going until you reach the one containing the object. This works, but it's quite wasteful as you send up to 8 requests for one object.</p>  https:// t c X.rbxcdn.com/ <p>A common implementation is as follows: Create a function that takes in a string <code>hash</code>. In this function, define <code>x</code> to <code>31</code>. Next, we loop through the first 32 characters in <code>hash</code>, and in each iteration set the <code>x</code> variable to itself bitwise  XORed against the integer representation of that character (<code>x ^= chr</code>). Then we return <code>x</code>.</p> <p>We can then use the <code>x</code> variable to compose the final URL with the pattern <code>https://t{x}.rbxcdn.com/{hash}</code>.</p> <p>Here are some test cases for this function: <pre><code>func(\"bbdb80c2b573bf222da3e92f5f148330\") -&gt; 5\nfunc(\"139602eb7c640c43833470e07caada4a\") -&gt; 7\nfunc(\"b717c50234c3d91b0be7dbfc9c588ed4\") -&gt; 0\n</code></pre></p>"},{"location":"cdn-hashes/#examples","title":"Examples","text":"PythonGoElixiramd64 Linux NASM AssemblyJavaScriptC#RubyC++CRustLua 5.3Lua 5.2/LuauJavaKotlinCrystalF#PowerShell <pre><code>def get_cdn_url(hash):\n    i = 31\n    for char in hash[:32]:\n        i ^= ord(char)  # i ^= int(char, 16) also works\n    return f\"https://t{i%8}.rbxcdn.com/{hash}\"\n\n# alternatively:\nfrom functools import reduce\n\ndef get_cdn_url(hash):\n    t = reduce(lambda last_code, char: last_code ^ ord(char), hash, 31)\n\n    return f\"https://t{t % 8}.rbxcdn.com/{hash}\"\n</code></pre> <pre><code>package pkg\n\nimport \"fmt\"\n\nfunc GetCdnUrl(hash string) string {\n    if hash == \"\" {\n        panic(\"hash is empty\")\n    }\n\n    var i int = 31\n\n    for _, char := range hash {\n        i = i ^ int(char)\n    }\n\n    return fmt.Sprintf(\"https://t%d.rbxcdn.com/%s\", i%8, hash)\n}\n</code></pre> <pre><code>defmodule CDN do\n  @spec get_cdn_url(String.t()) :: String.t()\n  def get_cdn_url(hash) do\n    t =\n      hash\n      |&gt; String.to_charlist()\n      |&gt; Enum.reduce(31, fn char, last_code -&gt; Bitwise.bxor(last_code, char) end)\n\n    \"https://t#{rem(t, 8)}.rbxcdn.com/#{hash}\"\n  end\nend\n</code></pre> <p>Commands to run, tested on an amd64 Arch Linux installation: <pre><code>nasm -felf64 cdn_hash.asm -o cdn_hash.o\ngcc -m64 -o cdn_hash cdn_hash.o\n./cdn_hash\n</code></pre></p> <pre><code>extern printf, snprintf\n\nsection .text\n    global main\n\nget_cdn_url:\n    push rdi\n    push rsi\n    push rdx\n    push rcx\n    push r8\n    push rax\n\n    ; rdi is the accumulator\n    mov rdi, 31\n\n    jmp .is_at_end\n\n.xor_t:\n    ; zero-extend the character (1 byte) so the other 7 bytes of rdx do not contain garbage data, from my testing it works\n    ; even with the garbage but it's better to be safe\n    movzx rdx, byte [rax]\n    xor rdi, rdx\n\n    ; increment hash pointer\n    inc rax\n\n.is_at_end:\n    cmp byte [rax], 0\n    jne .xor_t\n\n.fmt_cdn_url:\n    mov rax, rdi\n    xor rdx, rdx\n    mov rsi, 8\n    div rsi\n\n    ; t\n    mov rcx, rdx\n    ; buffer\n    lea rdi, [rel cdn_url]\n    ; buffer size\n    mov rsi, 55\n    ; format\n    lea rdx, [rel url_fmt]\n    ; hash\n    pop rax\n    mov r8, rax\n    push rax\n    xor rax, rax\n    call [rel snprintf wrt ..got]\n\n    pop rax\n    pop r8\n    pop rcx\n    pop rdx\n    pop rsi\n    pop rdi\n\n    ret\n\nmain:\n    lea rax, [rel hash]\n    call get_cdn_url\n\n    lea rdi, [rel s_fmt]\n    lea rsi, [rel cdn_url]\n    xor rax, rax\n    call [rel printf wrt ..got] \n\n    mov rax, 60\n    xor rdi, rdi\n    syscall\n\nsection .data\n    cdn_url: times 55 db 0\n    s_fmt: db \"%s\", 10, 0\n    url_fmt: db \"https://t%d.rbxcdn.com/%s\", 0\n    hash: db \"bbdb80c2b573bf222da3e92f5f148330\", 0\n</code></pre> <pre><code>const getCdnUrl = (hash) =&gt; {\n    const t = [...hash].reduce((lastCode, char) =&gt; lastCode ^ char.charCodeAt(0), 31);\n\n    return `https://t${t % 8}.rbxcdn.com/${hash}`;\n}\n</code></pre> <pre><code>using System;\nusing System.Linq;\n\nstring GetCdnUrl(string hash) {\n     int t =  hash.ToCharArray().Aggregate(31, (lastCode, character) =&gt; lastCode ^ (int)character);\n\n     return $\"https://t{t % 8}.rbxcdn.com/{hash}\";\n}\n</code></pre> <pre><code>def get_cdn_url(hash)\n  t = hash.codepoints.reduce(31) { |last_code, code| last_code ^ code }\n  \"https://t#{t % 8}.rbxcdn.com/#{hash}\"\nend\n</code></pre> <pre><code>std::string getCdnUrl(const std::string&amp; hash)\n{\n    if (hash.empty()) throw std::exception(\"Hash cannot be empty\");\n\n    int i = 31;\n\n    for (char const&amp; c : hash)\n    {\n        i ^= (int)c;\n    }\n\n    char buff[100];\n    snprintf(buff, sizeof(buff), \"https://t%d.rbxcdn.com/%s\", i % 8, hash.c_str());\n\n    return std::string(buff);\n}\n</code></pre> <pre><code>void getCdnUrl(char *hash, char *buffer) {\n    int i = 31;\n    for (int j = 0; j &lt; strlen(hash); j++) {\n        i ^= (int)hash[j];\n    }\n\n    snprintf(buffer, 55, \"https://t%d.rbxcdn.com/%s\", i % 8, hash);\n}\n</code></pre> <pre><code>fn get_cdn_url(hash: &amp;str) -&gt; String {\n    let t = hash.as_bytes().iter().fold(31, |last_code, code| {\n        last_code ^ code\n    });\n\n    format!(\"https://t{}.rbxcdn.com/{}\", t % 8, hash)\n}\n</code></pre> <pre><code>local function getCdnUrl(hash)\n    local i = 31\n    for _, code in utf8.codes(hash) do\n        i = i ~ code\n    end\n\n    return string.format(\"https://t%d.rbxcdn.com/%s\", i % 8, hash)\nend\n</code></pre> <pre><code>local function getCdnUrl(hash)\n    local i = 31\n    for _, code in utf8.codes(hash) do\n        i = bit32.bxor(i, code)\n    end\n\n    return string.format(\"https://t%d.rbxcdn.com/%s\", i % 8, hash)\nend\n</code></pre> <pre><code>String getCdnUrl(String hash) {\n    int i = 31;\n    for (char character : hash.toCharArray()) {\n        i ^= (int) character;\n    }\n\n    return String.format(\"https://t%d.rbxcdn.com/%s\", i % 8, hash);\n}\n</code></pre> <pre><code>fun getCdnUrl(hash: String): String {\n    val t = hash.toByteArray().fold(31) {acc, code -&gt; acc xor code.toInt()}\n\n    return \"https://t${t % 8}.rbxcdn.com/${hash}\"\n}\n</code></pre> <pre><code>def get_cdn_url(hash : String): String\n  t = hash.codepoints.reduce(31) { |last_code, code| last_code ^ code }\n  \"https://t#{t % 8}.rbxcdn.com/#{hash}\"\nend\n</code></pre> <pre><code>let getCdnUrl (hash: string) =\n    let t = hash |&gt; Seq.fold (fun lastCode char -&gt; lastCode ^^^ (int)char) 31\n\n    $\"https://t{t % 8}.rbxcdn.com/{hash}\"\n</code></pre> <pre><code>function get-cdn-url {\n    param (\n        [string] $hash\n    )\n\n    if ([string]::IsNullOrEmpty($hash)) { throw [System.ArgumentNullException]::new(\"hash\"); }\n\n    [int] $i = 31;\n\n    foreach ($c in $hash.ToCharArray()) {\n        $i = $i -bxor $c;\n    }\n\n    return \"https://t$($i % 8).rbxcdn.com/$($hash)\"\n}\n</code></pre>"},{"location":"list-of-asset-types/","title":"List of asset types","text":"ID Name 1 Image 2 T-Shirt 3 Audio 4 Mesh 5 Lua 6 HTML 7 Text 8 Hat 9 Place 10 Model 11 Shirt 12 Pants 13 Decal 16 Avatar 17 Head 18 Face 19 Gear 21 Badge 22 Group Emblem 24 Animation 25 Arms 26 Legs 27 Torso 28 Right Arm 29 Left Arm 30 Left Leg 31 Right Leg 32 Package 33 YouTubeVideo 34 Pass 35 App 37 Code 38 Plugin 39 SolidModel 40 MeshPart 41 Hair Accessory 42 Face Accessory 43 Neck Accessory 44 Shoulder Accessory 45 Front Accessory 46 Back Accessory 47 Waist Accessory 48 Climb Animation 49 Death Animation 50 Fall Animation 51 Idle Animation 52 Jump Animation 53 Run Animation 54 Swim Animation 55 Walk Animation 56 Pose Animation 59 LocalizationTableManifest 60 LocalizationTableTranslation 61 Emote Animation 62 Video 63 TexturePack 64 T-Shirt Accessory 65 Shirt Accessory 66 Pants Accessory 67 Jacket Accessory 68 Sweater Accessory 69 Shorts Accessory 70 Left Shoe Accessory 71 Right Shoe Accessory 72 Dress Skirt Accessory 73 Font Family 74 Font Face 75 MeshHiddenSurfaceRemoval 76 Eyebrow Accessory 77 Eyelash Accessory 78 Mood Animation 79 Dynamic Head 80 CodeSnippet"},{"location":"list-of-game-templates/","title":"List of game templates","text":"<p>All information fetched from <code>https://develop.roblox.com/v1/gametemplates</code>. Downloads are from the Roblox official CDN. Downloads will not have an <code>.rbxl</code> extension, but they are rbxl files.</p> Name Type Created Updated  Racing  Gameplay 02/12/2015 04/04/2019  Obby  Gameplay 01/14/2015 04/05/2019  Line Runner  Gameplay 09/28/2015 04/04/2019  Capture The Flag  Gameplay 11/01/2013 04/04/2019  Team/FFA Arena  Gameplay 09/28/2015 11/19/2019  Combat  Gameplay 01/14/2015 11/19/2019  Baseplate  Generic 11/01/2013 07/08/2019  Classic Baseplate  Generic 03/23/2021 04/16/2021  Flat Terrain  Generic 11/01/2013 07/08/2019  Move It Simulator  Generic 07/15/2020 07/15/2020  Mansion of Wonder  Generic 06/10/2021 06/10/2021  Concert  Theme 07/18/2022 07/18/2022  Village  Theme 10/10/2016 11/19/2019  Castle  Theme 01/14/2015 04/04/2019  Suburban  Theme 02/19/2016 06/20/2019  Pirate Island  Theme 07/01/2015 04/05/2019  City  Theme 01/14/2015 04/04/2019  Starting Place  Theme 03/09/2016 04/05/2019"},{"location":"list-of-libraries/","title":"List of libraries","text":"<p>The Roblox API is powerful, but it can be frustrating to use without any help. Instead of sending requests on your own, consider using a Roblox API \"wrapper\" library. These libraries send requests for you and can help you create apps faster.</p> <p>If none of these libraries are your thing, continue to the Tutorial to learn how to send requests on your own.</p> Name Language Links ro.py  Python 3  Source  Docs bloxy  JavaScript  Source  Docs noblox.js  JavaScript  Source  Docs dynablox_opencloud  JavaScript  Source  Docs openblox  TypeScript  Source  Docs"},{"location":"tutorial/","title":"Get started","text":"<p>Note</p> <p>This tutorial covers usage of Roblox's \"BEDEV1\" APIs, which are much more comprehensive than the newer \"Open Cloud\" APIs. Consider checking Roblox's official Open Cloud docs to see if your usecase is supported.</p> <p>There are two main ways you\u2019ll want to access the Roblox API: sending the requests yourself or using one of the API  wrappers available for your programming language of choice. </p> <p>This tutorial covers sending requests yourself. Before you attempt this, it is encouraged that you take a look at the List of libraries and see if any libraries cover your use case.</p>"},{"location":"tutorial/authentication/","title":"Authentication","text":"<p>Authentication is required for accessing the majority of resources on Roblox. Authentication can usually be granted with a cookie such as the <code>.ROBLOSECURITY</code> cookie. It will allow us to send API requests as a logged-in user, which will enable you to write bots that can modify content on the Roblox platform (for example, ranking a user in a group). To do this, we need to get our .ROBLOSECURITY cookie.</p>"},{"location":"tutorial/authentication/#roblosecurity","title":".ROBLOSECURITY","text":"<p>The .ROBLOSECURITY token is placed in the client's cookies and identifies the user's active session. The cookie must be named .ROBLOSECURITY and contains a value similar to this:</p> <pre><code>_|WARNING:-DO-NOT-SHARE-THIS.--Sharing-this-will-allow-someone-to-log-in-as-you-and-to-steal-your-ROBUX-and-items.|_TOKEN\n</code></pre> <p>The TOKEN is a capitalized hexadecimal string, roughly around 600 characters in length.</p> <p>Danger</p> <p>You may have heard of this token before and have been told that you should never, under any circumstances, share this token with anyone - and this is true! This token does give an attacker access to your Roblox account. However, this doesn't mean they gain access to everything - over time, more and more things are being locked behind other verification methods, like 2-step verification. We recommend using an alternate account with only the permissions it needs to limit the destruction an attacker can do. Always enable 2-step verification!</p>"},{"location":"tutorial/authentication/#obtaining-the-cookie","title":"Obtaining the cookie","text":"<p>To grab your .ROBLOSECURITY cookie, log into your account on the Roblox website and follow the instructions below.</p> <p>Warning</p> <p>Pressing the \"Log out\" button on the Roblox website invalidates your token, so you should not press this button after grabbing your token. Instead, consider using a private or incognito window and closing it when you are done.</p> Chrome/Chromium-basedFirefox <p>You can access the cookie by going to https://www.roblox.com/, pressing the padlock icon next to the URL in your browser, clicking the arrow next to <code>roblox.com</code>, opening up the \"Cookies\" folder, clicking \".ROBLOSECURITY\", clicking on the \"Content\" text once, pressing Ctrl+A, and then pressing Ctrl+C (make sure not to double-click this field as you won't select the entire value!)</p> <p></p> <p>Alternatively, you can access the cookie by going to https://www.roblox.com/, pressing Ctrl+Shift+I to access the Developer Tools, navigating to the \"Application\" tab, opening up the arrow next to \"Cookies\" on the sidebar on the left, clicking the <code>https://www.roblox.com</code> item underneath the Cookies button, and then copying the .ROBLOSECURITY token by double-clicking on the value and then hitting Ctrl+C.</p> <p></p> <p>You can access the cookie by going to https://www.roblox.com/ and pressing Shift+F9, pressing the \"Storage\" tab button on the top, opening up the \"Cookies\" section in the sidebar on the left, clicking the <code>https://www.roblox.com</code> item underneath it, and then copying the .ROBLOSECURITY token by double-clicking on the value and then hitting Ctrl+C.</p> <p></p>"},{"location":"tutorial/authentication/#the-warning-message","title":"The warning message","text":"<p>The warning message is not required, however, the bounding characters <code>_|</code> and <code>|_</code> are required for adding a message to the cookie's value and acts similarly to a comment in Computer Programming.</p>  Tokens that would work  Tokens that wouldn't work _|Example text|_TOKEN Example text_TOKEN _||_TOKEN _TOKEN TOKEN Example textTOKEN"},{"location":"tutorial/authentication/#authenticating-in-practice","title":"Authenticating in practice","text":"PythonRubyJavaScriptRustF# <p>It may be preferable to utilize the \"session\" object provided by the requests library. This example demonstrates making requests with and without the use of a session object. <pre><code>import requests\n\ncookie = \"_|WARNING:-DO-NOT-SHARE-THIS.--Sharing-this-will-allow-someone-to-log-in-as-you-and-to-steal-your-ROBUX-and-items.|_TOKEN\"\n\n# No session, with cookie dict\nreq = requests.get(\n    url=\"https://users.roblox.com/v1/users/authenticated\",\n    cookies={\n        \".ROBLOSECURITY\": cookie\n    }\n)\n\n# No session, without cookie dict\nreq = requests.get(\n    url=\"https://users.roblox.com/v1/users/authenticated\",\n    headers={\n        \"Cookie\": \".ROBLOSECURITY=\" + cookie\n    }\n)\n\n# With session\nsession = requests.Session()\nsession.cookies[\".ROBLOSECURITY\"] = cookie\nreq = session.get(\n    url=\"https://users.roblox.com/v1/users/authenticated\"\n)\n\nprint(req.text)\n</code></pre></p> <p>Requires the http.rb and json gems. <pre><code>require \"http\"\nrequire \"json\"\n\nCOOKIE = \"_|WARNING:-DO-NOT-SHARE-THIS.--Sharing-this-will-allow-someone-to-log-in-as-you-and-to-steal-your-ROBUX-and-items.|_TOKEN\"\n\nresponse = HTTP.cookies({\n    :\".ROBLOSECURITY\" =&gt; COOKIE\n}).get(\"https://users.roblox.com/v1/users/authenticated\")\n\nputs response.body.to_s\n</code></pre></p> <p>If your runtime doesn't support native fetch, like for example pre-v21 Node.js, you may need to install a package like node-fetch. <pre><code>const COOKIE = \"_|WARNING:-DO-NOT-SHARE-THIS.--Sharing-this-will-allow-someone-to-log-in-as-you-and-to-steal-your-ROBUX-and-items.|_TOKEN\";\n\nconst response = await fetch(\n    \"https://users.roblox.com/v1/users/authenticated\",\n    {\n        headers: {\n            Cookie: `.ROBLOSECURITY=${COOKIE};`,\n        },\n    }\n);\n\nconsole.log(await response.json());\n</code></pre></p> <p>Requires the reqwest crate. <pre><code>use reqwest::header::HeaderMap;\nuse reqwest::{Client, Method};\n\nconst COOKIE: &amp;str = \"_|WARNING:-DO-NOT-SHARE-THIS.--Sharing-this-will-allow-someone-to-log-in-as-you-and-to-steal-your-ROBUX-and-items.|_TOKEN\";\n\n#[tokio::main]\nasync fn main() {\n    let client = Client::new();\n    let mut headers = HeaderMap::new();\n    headers.insert(\n        \"Cookie\",\n        format!(\".ROBLOSECURITY={};\", COOKIE).parse().unwrap(),\n    );\n\n    let response = client\n        .request(\n            Method::GET,\n            \"https://users.roblox.com/v1/users/authenticated\",\n        )\n        .headers(headers)\n        .send()\n        .await\n        .unwrap();\n    println!(\"{}\", response.text().await.unwrap());\n}\n</code></pre></p> <pre><code>open System.Net\nopen System.Net.Http\n\n[&lt;Literal&gt;]\nlet COOKIE =\n    \"_|WARNING:-DO-NOT-SHARE-THIS.--Sharing-this-will-allow-someone-to-log-in-as-you-and-to-steal-your-ROBUX-and-items.|_TOKEN\"\n\n(task {\n    let cookieContainer = CookieContainer()\n    cookieContainer.Add(Cookie(\".ROBLOSECURITY\", COOKIE, Domain = \".roblox.com\"))\n\n    use httpClient =\n        new HttpClient(new HttpClientHandler(UseCookies = true, CookieContainer = cookieContainer))\n\n    let! response =\n        httpClient.SendAsync(new HttpRequestMessage(HttpMethod.Get, \"https://users.roblox.com/v1/users/authenticated\"))\n\n    let! body = response.Content.ReadAsStringAsync()\n    printfn \"%s\" body\n})\n    .Wait()\n</code></pre>"},{"location":"tutorial/handling-errors/","title":"Handling errors","text":"<p>Here\u2019s an example of an error returned from the users.roblox.com/v1/users/{userId} endpoint, you can test this yourself by going to https://users.roblox.com/v1/users/4:</p> <pre><code>{\n    \"errors\": [\n        {\n            \"code\": 3,\n            \"message\": \"The user id is invalid.\",\n            \"userFacingMessage\": \"Something went wrong\"\n        }\n    ]\n}\n</code></pre> <p>As you can see, it\u2019s an errors list containing objects with a code, message, and userFacingMessage.</p> <ul> <li>The <code>code</code> is an identifier used for an error on an endpoint.</li> <li>The <code>message</code> is information about the error intended for the developer.</li> <li>The <code>userFacingMessage</code> is information about the error indented for the user. It isn\u2019t always present and often isn\u2019t     as informative as the message.</li> </ul> <p>We can use this code along with the HTTP response code (in this case, 404) and the endpoint\u2019s \"Responses\" section from the documentation to find more information.</p> <p></p> <p>In this case, it\u2019s just telling us what we already know from the message. There are many cases where the API just doesn't give us useful information, like this:</p> <pre><code>{\n    \"errors\": [\n        {\n            \"code\": 0,\n            \"message\": \"Something went wrong with the request, see response status code.\"\n        }\n    ]\n}\n</code></pre> <p>In this case, we don\u2019t get much information - the best we can do is use the documentation to try to figure out what\u2019s wrong here.</p>"},{"location":"tutorial/understanding-documentation/","title":"Understanding documentation","text":"<p>Each documentation page contains a list of public endpoints available on that domain and information about how to use them.</p>"},{"location":"tutorial/understanding-documentation/#accessing-documentation","title":"Accessing documentation","text":"<p>The Roblox API is broken down into services, like <code>users</code>, <code>groups</code>, and <code>friends</code>. In general, each service has endpoints that generally involve one main concept, like \"user information\" or \"friend management\".</p> <p>Each service has a separate subdomain on <code>roblox.com</code>, like <code>users.roblox.com</code> or <code>friends.roblox.com</code>. The documentation for that service is available via the <code>/docs</code> route, like https://users.roblox.com/docs.  Not all services have available documentation, and not all endpoints on those services are visible.</p> <p>To find the service you need, see List of services. </p>"},{"location":"tutorial/understanding-documentation/#endpoint-documentation","title":"Endpoint documentation","text":"<p>Documentation for all types of requests will always contain the following:  </p> <ul> <li>The text in top left corner and the background color differ depending on the method of the request.</li> <li>Example Value contains an example of what the response from this endpoint might look like.</li> <li>Response Content Type determines what should be passed to the <code>Accept</code> header.   Usually you'll want this to be <code>application/json</code>.</li> <li>Parameters determines what data is passed to the endpoint when sending the request.    The Parameter Type determines how the parameter will be passed to the endpoint, like as a query string or    as a part of the URL.</li> <li>Response Messages explain what different endpoint status codes mean when they are returned from this endpoint.</li> <li>The \"Try it out!\" button sends a request to this endpoint with the specified parameters.</li> </ul> <p></p> <p>Requests with a body, like POST, PUT, PATCH, and DELETE, have an additional parameter labelled <code>request</code> which contains the request body.</p> <p>You can also change the body's content type. In almost all cases this should remain set to <code>application/json</code>.  The \"Example Value\" contains an example of the data you should provide in the request body. Clicking on that Example Value will set the body to the example data. This is useful for quickly testing an endpoint before implementing it into your program.</p>"},{"location":"tutorial/x-csrf-token/","title":"X-CSRF-TOKEN","text":"<p>At this point, we\u2019re now authenticated - but there\u2019s one thing missing. If we try to send a POST request, you\u2019ll notice that the request still fails.</p> <p>Here's an example of some code that won't work due to the <code>X-CSRF-TOKEN</code>: </p> PythonRubyJavaScriptRustF#C#Elixir <pre><code>import requests\n\ncookie = \"_|WARNING:-DO-NOT-SHARE-THIS.--Sharing-this-will-allow-someone-to-log-in-as-you-and-to-steal-your-ROBUX-and-items.|_TOKEN\"\n\nsession = requests.Session()\nsession.cookies[\".ROBLOSECURITY\"] = cookie\nreq = session.post(\n    url=\"https://auth.roblox.com/v2/login\"\n)\nerror = req.json()\n\nprint(req.status_code)\nprint(\"Error code:\", error[\"code\"])\nprint(\"Error message:\", error[\"message\"])\n</code></pre> <p>Requires the http.rb and json gems. <pre><code>require \"http\"\nrequire \"json\"\n\nCOOKIE = \"_|WARNING:-DO-NOT-SHARE-THIS.--Sharing-this-will-allow-someone-to-log-in-as-you-and-to-steal-your-ROBUX-and-items.|_TOKEN\"\n\nresponse = HTTP.cookies({\n  \".ROBLOSECURITY\": COOKIE\n}).post(\"https://auth.roblox.com\")\nerror = JSON.parse(response)\n\nputs response.status\nputs \"Error code: #{error['code']}\"\nputs \"Error message: #{error['message']}\"\n</code></pre></p> <p>If your runtime doesn't support native fetch, like for example pre-v21 Node.js, you may need to install a package like node-fetch. <pre><code>const COOKIE = \"_|WARNING:-DO-NOT-SHARE-THIS.--Sharing-this-will-allow-someone-to-log-in-as-you-and-to-steal-your-ROBUX-and-items.|_TOKEN\";\n\nconst response = await fetch(\"https://auth.roblox.com\", {\n    headers: {\n        Cookie: `.ROBLOSECURITY=${COOKIE};`,\n        \"Content-Length\": \"0\",\n    },\n    method: \"POST\",\n});\nconst body = await response.json();\n\nconsole.log(response.status);\nconsole.log(`Error code: ${body.code}`)\nconsole.log(`Error message: ${body.message}`)\n</code></pre></p> <p>Requires the reqwest, tokio and serde_json crates. <pre><code>use reqwest::header::HeaderMap;\nuse reqwest::Client;\nuse serde_json::{from_str, Value};\n\nconst COOKIE: &amp;str = \"_|WARNING:-DO-NOT-SHARE-THIS.--Sharing-this-will-allow-someone-to-log-in-as-you-and-to-steal-your-ROBUX-and-items.|_TOKEN\";\n\n#[tokio::main]\nasync fn main() {\n    let client = Client::new();\n    let mut headers = HeaderMap::new();\n    headers.insert(\n        \"Cookie\",\n        format!(\".ROBLOSECURITY={};\", COOKIE).parse().unwrap(),\n    );\n\n    let response = client\n        .post(\"https://auth.roblox.com\")\n        .headers(headers)\n        .send()\n        .await\n        .unwrap();\n\n    let status = response.status(); // get status here because .text() consumes the response\n    let body: Value = from_str(&amp;response.text().await.unwrap()).unwrap();\n\n    println!(\"{}\", status);\n    println!(\"Error code: {}\", body[\"code\"]);\n    println!(\"Error message: {}\", body[\"message\"]);\n}\n</code></pre></p> <pre><code>open System.Net\nopen System.Net.Http\nopen System.Text.Json\n\ntype Error = { code: int; message: string }\n\n[&lt;Literal&gt;]\nlet COOKIE =\n    \"_|WARNING:-DO-NOT-SHARE-THIS.--Sharing-this-will-allow-someone-to-log-in-as-you-and-to-steal-your-ROBUX-and-items.|_TOKEN\"\n\n(task {\n    let cookieContainer = CookieContainer()\n    cookieContainer.Add(Cookie(\".ROBLOSECURITY\", COOKIE, Domain = \".roblox.com\"))\n\n    use httpClient =\n        new HttpClient(new HttpClientHandler(UseCookies = true, CookieContainer = cookieContainer))\n\n    let! response = httpClient.SendAsync(new HttpRequestMessage(HttpMethod.Post, \"https://auth.roblox.com/\"))\n    let! content = response.Content.ReadAsStreamAsync()\n    let! error = JsonSerializer.DeserializeAsync&lt;Error&gt;(content)\n\n    printfn \"%d\" (int response.StatusCode)\n    printfn \"Error code: %d\" error.code\n    printfn \"Error message: %s\" error.message\n})\n    .Wait()\n</code></pre> <pre><code>using System.Net;\nusing System.Net.Http;\nusing System.Text.Json;\n\nconst string COOKIE = \"_|WARNING:-DO-NOT-SHARE-THIS.--Sharing-this-will-allow-someone-to-log-in-as-you-and-to-steal-your-ROBUX-and-items.|_TOKEN\";\n\nvar cookieContainer = new CookieContainer();\ncookieContainer.Add(new Cookie(\".ROBLOSECURITY\", COOKIE) { Domain = \".roblox.com\" });\n\nvar client = new HttpClient(new HttpClientHandler() { UseCookies = true, CookieContainer = cookieContainer });\n\nvar response = await client.PostAsync(\"https://auth.roblox.com/\", null);\ndynamic body = JsonSerializer.Deserialize&lt;dynamic&gt;(\n    await response.Content.ReadAsStringAsync()\n);\n\nConsole.WriteLine(((int)response.StatusCode).ToString());\nConsole.WriteLine($\"Error code: {body.GetProperty(\"code\")}\");\nConsole.WriteLine($\"Error message: {body.GetProperty(\"message\")}\");\n</code></pre> <p>Compile with <code>iex -S mix</code>, then execute <code>RobloxAPI.main</code>.</p> <p>Dependencies: httpoison and poison <pre><code>defmodule RobloxAPI do\n  @roblosecurity \"_|WARNING:-DO-NOT-SHARE-THIS.--Sharing-this-will-allow-someone-to-log-in-as-you-and-to-steal-your-ROBUX-and-items.|_TOKEN\"\n\n  def main do\n    headers = %{Cookie: \".ROBLOSECURITY=#{@roblosecurity};\"}\n\n    with {:ok, response} &lt;- HTTPoison.post(\"https://auth.roblox.com\", \"\", headers),\n         {:ok, body} &lt;- Poison.decode(response.body) do\n      IO.puts(response.status_code)\n      IO.puts(\"Error code: #{body[\"code\"]}\")\n      IO.puts(\"Error message: #{body[\"message\"]}\")\n    else\n      {:error, error} -&gt;\n        IO.inspect(error)\n    end\n  end\nend\n</code></pre></p> <p>This code should output something like the following:</p> <pre><code>403\nError code: 0\nError message: Token Validation Failed\n</code></pre> <p>The <code>403 Forbidden</code> status code is returned when the client \"is not permitted access to the resource despite providing authentication such as insufficient permissions of the authenticated account\".</p> <p>If you saw this while trying to write your own code to access the API, you might ask \"why is this error coming up? My .ROBLOSECURITY token is correct, and it worked when I used the \"Try it out!\" button on the documentation page.\"</p> <p>The truth is that this error message isn\u2019t referring to \"token\" as in your .ROBLOSECURITY token - it\u2019s actually referring to a header that you have to supply to all requests that change data called the <code>X-CSRF-TOKEN</code>. It is used to prevent a cross-site request forgery attack, which would enable a malicious website to send an authenticated request to the Roblox API if you have a logged-in session in your browser.</p> <p>To handle this token, each time we send a request, we'll save the <code>X-CSRF-TOKEN</code> - which is present in the response headers - to a value. Then, if the request failed with a status code of 403, and one of the errors has the code 0, we'll send the request again with the <code>X-CSRF-TOKEN</code> we just got the first request as a request header. </p> PythonRubyJavaScriptRustC#Elixir <pre><code># With the Session object, we can just store the token in the headers dictionary, but you can pass them directly to each request as well.\nimport requests\n\ncookie = \"_|WARNING:-DO-NOT-SHARE-THIS.--Sharing-this-will-allow-someone-to-log-in-as-you-and-to-steal-your-ROBUX-and-items.|_TOKEN\"\n\nsession = requests.Session()\nsession.cookies[\".ROBLOSECURITY\"] = cookie\n\n# send first request\nreq = session.post(\n    url=\"https://auth.roblox.com/\"\n)\n\nif \"X-CSRF-Token\" in req.headers:  # check if token is in response headers\n    session.headers[\"X-CSRF-Token\"] = req.headers[\"X-CSRF-Token\"]  # store the response header in the session\n\n# send second request\nreq2 = session.post(\n    url=\"https://auth.roblox.com/\"\n)\n\nprint(\"First:\", req.status_code)\nprint(\"Second:\", req2.status_code)\n</code></pre> <p>Requires the http.rb and json gems. <pre><code>require \"http\"\nrequire \"json\"\n\nCOOKIE = \"_|WARNING:-DO-NOT-SHARE-THIS.--Sharing-this-will-allow-someone-to-log-in-as-you-and-to-steal-your-ROBUX-and-items.|_TOKEN\"\n\nclient = HTTP.cookies({\n    \".ROBLOSECURITY\": COOKIE\n})\n\nfirst_response = client.post(\"https://auth.roblox.com\")\n\nclient = client.headers({\n    \"x-csrf-token\": first_response.headers[\"x-csrf-token\"]\n})\n\nsecond_response = client.post(\"https://auth.roblox.com\")\n\nputs \"First: #{first_response.status}\"\nputs \"Second: #{second_response.status}\"\n</code></pre></p> <p>If your runtime doesn't support native fetch, like for example pre-v21 Node.js, you may need to install a package like node-fetch. <pre><code>const COOKIE = \"_|WARNING:-DO-NOT-SHARE-THIS.--Sharing-this-will-allow-someone-to-log-in-as-you-and-to-steal-your-ROBUX-and-items.|_TOKEN\";\n\nconst firstResponse = await fetch(\"https://auth.roblox.com\", {\n    headers: {\n        Cookie: `.ROBLOSECURITY=${COOKIE};`,\n        \"Content-Length\": \"0\",\n    },\n    method: \"POST\",\n});\n\nconst secondResponse = await fetch(\"https://auth.roblox.com\", {\n    headers: {\n        Cookie: `.ROBLOSECURITY=${COOKIE};`,\n        \"x-csrf-token\": firstResponse.headers.get(\"x-csrf-token\"),\n        \"Content-Length\": \"0\",\n    },\n    method: \"POST\",\n});\n\nconsole.log(`First: ${firstResponse.status}`);\nconsole.log(`Second: ${secondResponse.status}`);\n</code></pre></p> <p>Requires the reqwest and tokio crates. <pre><code>use reqwest::header::HeaderMap;\nuse reqwest::Client;\n\nconst COOKIE: &amp;str = \"_|WARNING:-DO-NOT-SHARE-THIS.--Sharing-this-will-allow-someone-to-log-in-as-you-and-to-steal-your-ROBUX-and-items.|_TOKEN\";\n\n#[tokio::main]\nasync fn main() {\n    let client = Client::new();\n    let mut headers = HeaderMap::new();\n    headers.insert(\n        \"Cookie\",\n        format!(\".ROBLOSECURITY={};\", COOKIE).parse().unwrap(),\n    );\n\n    let first_response = client\n        .post(\"https://auth.roblox.com\")\n        .headers(headers)\n        .send()\n        .await\n        .unwrap();\n\n    let mut headers = HeaderMap::new();\n    headers.insert(\n        \"Cookie\",\n        format!(\".ROBLOSECURITY={};\", COOKIE).parse().unwrap(),\n    );\n    headers.insert(\n        \"x-csrf-token\",\n        first_response\n            .headers()\n            .get(\"x-csrf-token\")\n            .unwrap()\n            .to_str()\n            .unwrap()\n            .parse()\n            .unwrap(),\n    );\n\n    let second_response = client\n        .post(\"https://auth.roblox.com\")\n        .headers(headers)\n        .send()\n        .await\n        .unwrap();\n\n    println!(\"First: {}\", first_response.status());\n    println!(\"Second: {}\", second_response.status());\n}\n</code></pre></p> <pre><code>using System.Net;\nusing System.Net.Http;\nusing System.Net.Http.Headers;\nusing System.Text.Json;\n\nconst string COOKIE = \"_|WARNING:-DO-NOT-SHARE-THIS.--Sharing-this-will-allow-someone-to-log-in-as-you-and-to-steal-your-ROBUX-and-items.|_TOKEN\";\n\nvar cookieContainer = new CookieContainer();\ncookieContainer.Add(new Cookie(\".ROBLOSECURITY\", COOKIE) { Domain = \".roblox.com\" });\n\nvar httpClient = new HttpClient(new HttpClientHandler() { UseCookies = true, CookieContainer = cookieContainer });\n\nvar firstResponse = await httpClient.PostAsync(\"https://auth.roblox.com/\", null);\nhttpClient.DefaultRequestHeaders.Add(\"x-csrf-token\", firstResponse.Headers.GetValues(\"x-csrf-token\").First());\n\nvar requestMessage = new HttpRequestMessage(HttpMethod.Post, \"https://auth.roblox.com/\");\nrequestMessage.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(\"application/json\"));\nvar secondResponse = await httpClient.SendAsync(requestMessage);\n\nConsole.WriteLine($\"First: {firstResponse.StatusCode}\");\nConsole.WriteLine($\"Second: {secondResponse.StatusCode}\");\n</code></pre> <p>Compile with <code>iex -S mix</code>, then execute <code>RobloxAPI.main</code>.</p> <p>Dependencies: httpoison and poison <pre><code>defmodule RobloxAPI do\n  @roblosecurity \"_|WARNING:-DO-NOT-SHARE-THIS.--Sharing-this-will-allow-someone-to-log-in-as-you-and-to-steal-your-ROBUX-and-items.|_TOKEN\"\n\n  def main do\n    headers = %{Cookie: \".ROBLOSECURITY=#{@roblosecurity};\"}\n\n    with {:ok, first_response} &lt;- HTTPoison.post(\"https://auth.roblox.com\", \"\", headers),\n         {:ok, second_response} &lt;-\n           HTTPoison.post(\n             \"https://auth.roblox.com\",\n             \"\",\n             Map.put(\n               headers,\n               :\"x-csrf-token\",\n               # response.headers is a list of tuples, where the first element is the header name and the second the header's value\n               Enum.find_value(first_response.headers, fn {name, value} -&gt;\n                 if name == \"x-csrf-token\", do: value\n               end)\n             )\n           ) do\n      IO.puts(\"First: #{first_response.status_code}\")\n      IO.puts(\"Second: #{second_response.status_code}\")\n    else\n      {:error, error} -&gt;\n        IO.inspect(error)\n    end\n  end\nend\n</code></pre></p> <p>This program will send one request, check if the X-CSRF-Token was present in the response, and if so will store it back into the session's headers. We then repeat the first request again, and then outputs the status codes from both requests.</p> <p>This code should output something like the following:</p> <pre><code>First: 403\nSecond: 200\n</code></pre> <p>This solution works - but it doesn't scale well. If we want to properly do this, we\u2019ll put all of this logic in a function that handles our requests for us and then call that when sending requests. This is (essentially) what the request wrappers in Roblox API wrapper libraries do.</p>"},{"location":"tutorial/x-csrf-token/#request-function","title":"Request function","text":"<p>Here's an example of a function that does what we need: </p> PythonF#RubyJavaScriptRustC#Elixir <pre><code>import requests\n\ncookie = \"_|WARNING:-DO-NOT-SHARE-THIS.--Sharing-this-will-allow-someone-to-log-in-as-you-and-to-steal-your-ROBUX-and-items.|_TOKEN\"\n\nsession = requests.Session()\nsession.cookies[\".ROBLOSECURITY\"] = cookie\n\n\ndef rbx_request(method, url, **kwargs):\n    request = session.request(method, url, **kwargs)\n    method = method.lower()\n    if method in {\"post\", \"put\", \"patch\", \"delete\"}:\n        if \"X-CSRF-TOKEN\" in request.headers:\n            session.headers[\"X-CSRF-TOKEN\"] = request.headers[\"X-CSRF-TOKEN\"]\n            if request.status_code == 403:\n                body = request.body()\n                if body.get(\"code\", -1) == 0: # Request failed, send it again\n                    request = session.request(method, url, **kwargs)\n    return request\n\n\nreq = rbx_request(\"POST\", \"https://auth.roblox.com/\")\nprint(req.status_code)\n</code></pre> <pre><code>open System.Net\nopen System.Net.Http\nopen System.Text.Json\n\ntype Error = { code: int; message: string }\n\n[&lt;Literal&gt;]\nlet COOKIE =\n    \"_|WARNING:-DO-NOT-SHARE-THIS.--Sharing-this-will-allow-someone-to-log-in-as-you-and-to-steal-your-ROBUX-and-items.|_TOKEN\"\n\nlet cookieContainer = CookieContainer()\ncookieContainer.Add(Cookie(\".ROBLOSECURITY\", COOKIE, Domain = \".roblox.com\"))\n\nlet httpClient =\n    new HttpClient(new HttpClientHandler(UseCookies = true, CookieContainer = cookieContainer))\n\nlet rec rbxRequest (method: HttpMethod) (url: string) (body: 'a option) =\n    task {\n        let! response =\n            httpClient.SendAsync(\n                new HttpRequestMessage(\n                    method,\n                    url,\n                    Content =\n                        new StringContent(\n                            JsonSerializer.Serialize(\n                                body\n                                |&gt; Option.defaultValue Unchecked.defaultof&lt;'a&gt;\n                            ),\n                            System.Text.Encoding.UTF8,\n                            \"application/json\"\n                        )\n                )\n            )\n\n        if response.StatusCode = HttpStatusCode.Forbidden then\n            let! content = response.Content.ReadAsStreamAsync()\n            let! error = JsonSerializer.DeserializeAsync&lt;Error&gt; content\n\n            if error.code = 0 then\n                httpClient.DefaultRequestHeaders.Add(\n                    \"x-csrf-token\",\n                    response.Headers.GetValues \"x-csrf-token\"\n                    |&gt; Seq.head\n                )\n\n                return! rbxRequest method url body\n            else\n                return Error response\n        else\n            return Ok response\n    }\n\n(task {\n    let! result = rbxRequest HttpMethod.Get \"https://auth.roblox.com/\" None\n\n    match result with\n    | Ok response -&gt; printfn \"%d\" (int response.StatusCode)\n    | Error error -&gt; failwithf \"Expected status code 200, got %d\" (int error.StatusCode)\n})\n    .Wait()\n</code></pre> <p>Requires the http.rb and json gems. <pre><code>require \"http\"\nrequire \"json\"\n\nCOOKIE = \"_|WARNING:-DO-NOT-SHARE-THIS.--Sharing-this-will-allow-someone-to-log-in-as-you-and-to-steal-your-ROBUX-and-items.|_TOKEN\"\nMETHODS = %i(post put patch delete)\n\nmodule APIHelper\n  @client = HTTP.cookies({\n    :\".ROBLOSECURITY\" =&gt; COOKIE\n  })\n\n  def self.rbx_request(verb, url, *args)\n    response = @client.request(verb, url, *args)\n\n    if METHODS.include?(verb) and response.headers.include?(\"x-csrf-token\")\n      @client = @client.headers({\n        \"x-csrf-token\": response.headers[\"x-csrf-token\"]\n      })\n\n      if response.status == 403\n        body = JSON.parse(response.body)\n        if body[\"code\"] == 0\n          response = rbx_request(verb, url, *args)\n        end\n      end\n    end\n\n    response\n  end\nend\n\nresponse = APIHelper.rbx_request(:post, \"https://auth.roblox.com\")\nputs response.status\n</code></pre></p> <p>If your runtime doesn't support native fetch, like for example pre-v21 Node.js, you may need to install a package like node-fetch. <pre><code>const COOKIE = \"_|WARNING:-DO-NOT-SHARE-THIS.--Sharing-this-will-allow-someone-to-log-in-as-you-and-to-steal-your-ROBUX-and-items.|_TOKEN\";\n\nlet xCsrfToken = \"\";\n\nconst rbxRequest = async (verb, url, body) =&gt; {\n    verb = verb.toUpperCase();\n    let response = await fetch(url, {\n        headers: {\n            Cookie: `.ROBLOSECURITY=${COOKIE};`,\n            \"x-csrf-token\": xCsrfToken,\n            \"Content-Length\": (body?.length ?? 0).toString(),\n        },\n        method: verb,\n        body: body || \"\",\n    });\n    if (\n        [\"POST\", \"PUT\", \"PATCH\", \"DELETE\"].includes(verb) &amp;&amp;\n        response.headers.has(\"x-csrf-token\")\n    ) {\n        xCsrfToken = response.headers.get(\"x-csrf-token\");\n        if (response.status == 403) {\n            const responseBody = await response.json();\n            if (responseBody.code === 0)\n                response = await rbxRequest(verb, url, body);\n        }\n    }\n    return response;\n};\n\nconst response = await rbxRequest(\"POST\", \"https://auth.roblox.com\");\nconsole.log(response.status);\n</code></pre></p> <p>Requires the reqwest, tokio, serde_json and lazy_static crates. <pre><code>use lazy_static::lazy_static;\nuse reqwest::{header::HeaderMap, Method};\nuse reqwest::{Client, Response, StatusCode};\nuse serde_json::{from_str, Value};\nuse std::sync::{Arc, Mutex};\n\nconst COOKIE: &amp;str = \"_|WARNING:-DO-NOT-SHARE-THIS.--Sharing-this-will-allow-someone-to-log-in-as-you-and-to-steal-your-ROBUX-and-items.|_TOKEN\";\n\nlazy_static! {\n    static ref HTTP_CLIENT: Client = Client::new();\n    static ref HEADERS: Arc&lt;Mutex&lt;HeaderMap&gt;&gt; = Arc::new(Mutex::new({\n        let mut headers = HeaderMap::new();\n        headers.insert(\n            \"Cookie\",\n            format!(\".ROBLOSECURITY={};\", COOKIE).parse().unwrap(),\n        );\n        headers\n    }));\n}\n\nasync fn request(verb: Method, url: String, body: Option&lt;Value&gt;) -&gt; Result&lt;Response, ()&gt; {\n    let arc_ref = HEADERS.clone(); // get reference to the arc here so it lives as long as headers\n    let mut headers = arc_ref.lock().unwrap();\n\n    let response = HTTP_CLIENT\n        .request(verb.clone(), url.clone())\n        .headers(headers.clone())\n        .json(&amp;body)\n        .send()\n        .await\n        .unwrap();\n\n    // this is kinda botched because on the branch where .text() is called and the code is not 0, there's no response to\n    // return because it's consumed, you can upgrade it to return the errors instead of unit, see for example\n    // https://github.com/zmadie/oxid_roblox/blob/5fbe3553871c048158d54269e3e0d57dbc78ab97/src/util/api_helper.rs#L54-L67\n    if let Some(x_csrf_token) = response.headers().get(\"x-csrf-token\").cloned() {\n        headers.insert(\"x-csrf-token\", x_csrf_token);\n        if response.status() == StatusCode::FORBIDDEN {\n            let body: Value = from_str(&amp;response.text().await.unwrap()).unwrap();\n            if body[\"code\"].as_i64().unwrap() == 0 {\n                return Ok(HTTP_CLIENT\n                    .request(verb, url)\n                    .headers(headers.clone())\n                    .json(&amp;body)\n                    .send()\n                    .await\n                    .unwrap());\n            } else {\n                return Err(());\n            }\n        }\n    }\n    Ok(response)\n}\n\n#[tokio::main]\nasync fn main() {\n    let response = request(\n        Method::GET,\n        \"https://users.roblox.com/v1/users/1\".to_string(),\n        None,\n    )\n    .await\n    .unwrap();\n\n    println!(\"{}\", response.status());\n}\n</code></pre></p> <pre><code>using System.Net;\nusing System.Net.Http;\nusing System.Text.Json;\n\nconst string COOKIE = \"_|WARNING:-DO-NOT-SHARE-THIS.--Sharing-this-will-allow-someone-to-log-in-as-you-and-to-steal-your-ROBUX-and-items.|_TOKEN\";\n\nvar cookieContainer = new CookieContainer();\ncookieContainer.Add(new Cookie(\".ROBLOSECURITY\", COOKIE) { Domain = \".roblox.com\" });\n\nvar httpClient = new HttpClient(new HttpClientHandler() { UseCookies = true, CookieContainer = cookieContainer });\nasync Task&lt;HttpResponseMessage&gt; Request(HttpMethod method, string url, dynamic body = null)\n{\n    var response = await httpClient.SendAsync(\n        new HttpRequestMessage(\n            method,\n            url\n        )\n        {\n            Content =\n                new StringContent(\n                    JsonSerializer.Serialize(body ?? new { }),\n                    Encoding.UTF8,\n                    \"application/json\"\n                )\n        }\n\n    );\n    if (response.StatusCode == HttpStatusCode.Forbidden)\n    {\n        dynamic error = await JsonSerializer.DeserializeAsync&lt;dynamic&gt;(await response.Content.ReadAsStreamAsync());\n        if (error.GetProperty(\"code\").GetInt32() == 0)\n        {\n            httpClient.DefaultRequestHeaders.Add(\"x-csrf-token\", response.Headers.GetValues(\"x-csrf-token\").First());\n            return await Request(method, url, body);\n        }\n    }\n\n    return response;\n}\n\nvar response = await Request(HttpMethod.Post, \"https://auth.roblox.com\");\nConsole.WriteLine(response.StatusCode);\n</code></pre> <p>Compile with <code>iex -S mix</code>, then execute <code>RobloxAPI.main</code>.</p> <p>Dependencies: httpoison and poison <pre><code>defmodule RobloxAPI do\n  use Agent\n\n  @roblosecurity \"_|WARNING:-DO-NOT-SHARE-THIS.--Sharing-this-will-allow-someone-to-log-in-as-you-and-to-steal-your-ROBUX-and-items.|_TOKEN\"\n\n  def start_link do\n    Agent.start_link(fn -&gt; %{Cookie: \".ROBLOSECURITY=#{@roblosecurity}\"} end, name: __MODULE__)\n  end\n\n  defp request(verb, url, body \\\\ %{}) do\n    headers = Agent.get(__MODULE__, &amp; &amp;1)\n\n    with {:ok, encoded_body} &lt;- Poison.encode(body),\n         {:ok, %HTTPoison.Response{status_code: 403} = response} &lt;-\n           HTTPoison.request(verb, url, encoded_body, headers),\n         {:ok, body} &lt;-\n           Poison.decode(response.body) do\n      xcsrf_token =\n        Enum.find_value(response.headers, fn {name, value} -&gt;\n          if name == \"x-csrf-token\", do: value\n        end)\n\n      if xcsrf_token == nil do\n        {:ok, response}\n      else\n        headers = Map.put(headers, :\"x-csrf-token\", xcsrf_token)\n        Agent.update(__MODULE__, fn _ -&gt; headers end)\n\n        if body[\"code\"] == 0 do\n          request(verb, url, body)\n        else\n          {:ok, response}\n        end\n      end\n    else\n      {:ok, response} -&gt;\n        {:ok, response}\n\n      {:error, error} -&gt;\n        {:error, error}\n    end\n  end\n\n  def main do\n    start_link()\n\n    case request(:post, \"https://auth.roblox.com\") do\n      {:ok, %HTTPoison.Response{status_code: status_code}} -&gt;\n        IO.puts(status_code)\n\n      {:error, error} -&gt;\n        IO.inspect(error)\n    end\n  end\nend\n</code></pre></p> <p>This code should output something like the following:</p> <pre><code>200\n</code></pre> <p>Now that we\u2019ve done this, sending any kind of requests to the API is boilerplate-less.</p>"},{"location":"tutorial/your-first-request/","title":"Your first request","text":"<p>At this point, you\u2019re ready to use most of the endpoints that take in GET requests on these domains, as they won\u2019t require authentication, like users.roblox.com/v1/users/{userId}. This endpoint returns response data that looks like this:</p> <pre><code>{\n    \"description\": \"Welcome to the Roblox profile! This is where you can check out the newest items in the catalog, and get a jumpstart on exploring and building on our Imagination Platform. If you want news on updates to the Roblox platform, or great new experiences to play with friends, check out blog.roblox.com. Please note, this is an automated account. If you need to reach Roblox for any customer service needs find help at www.roblox.com/help\",\n    \"created\": \"2006-02-27T21:06:40.3Z\",\n    \"isBanned\": false,\n    \"externalAppDisplayName\": null,\n    \"hasVerifiedBadge\": true,\n    \"id\": 1,\n    \"name\": \"Roblox\",\n    \"displayName\": \"Roblox\"\n}\n</code></pre> <p>You\u2019ll probably use this endpoint along with other endpoints on users.roblox.com quite a lot, as they are extremely useful for grabbing information about a user.</p> PythonRubyRustF#C#JavaScript <pre><code>import requests\n\nuser_id = 1  # User ID\nuser_req = requests.get(f\"https://users.roblox.com/v1/users/{user_id}\")\nuser_data = user_req.json()\n\nprint(\"Name:\", user_data[\"name\"])\nprint(\"Display Name:\", user_data[\"displayName\"])\nprint(\"User ID:\", user_data[\"id\"])\nprint(\"Description:\", user_data[\"description\"])\n</code></pre> <p>Requires the http.rb and json gems. <pre><code>require \"http\"\nrequire \"json\"\n\nUSER_ID = 1\nresponse = HTTP.get(\"https://users.roblox.com/v1/users/#{USER_ID}\")\nbody = JSON.parse(response.body)\n\nputs \"Username: #{body[\"name\"]}\"\nputs \"Display name: #{body[\"displayName\"]}\"\nputs \"User ID: #{body[\"id\"]}\"\nputs \"Description: #{body[\"description\"]}\"\n</code></pre></p> <p>Requires the reqwest, tokio and serde_json crates. <pre><code>use reqwest::get;\nuse serde_json::{from_str, Value};\n\nconst USER_ID: i64 = 1;\n\n#[tokio::main]\nasync fn main() {\n    let response = get(format!(\"https://users.roblox.com/v1/users/{}\", USER_ID))\n        .await\n        .unwrap()\n        .text()\n        .await\n        .unwrap();\n    let body: Value = from_str(&amp;response).unwrap();\n\n    println!(\"Username: {}\", body[\"name\"].as_str().unwrap());\n    println!(\"Display name: {}\", body[\"displayName\"].as_str().unwrap());\n    println!(\"User ID: {}\", body[\"id\"].as_i64().unwrap());\n    println!(\"Description: {}\", body[\"description\"].as_str().unwrap());\n}\n</code></pre></p> <pre><code>open System.Net.Http\nopen System.Text.Json\n\ntype Response =\n    { name: string\n      displayName: string\n      id: int\n      description: string }\n\n[&lt;Literal&gt;]\nlet USER_ID = 1\n\n(task {\n    use client = new HttpClient()\n    let! response = client.GetAsync $\"https://users.roblox.com/v1/users/{USER_ID}\"\n    let! content = response.Content.ReadAsStreamAsync()\n    let! body = JsonSerializer.DeserializeAsync&lt;Response&gt; content\n\n    printfn \"Username: %s\" body.name\n    printfn \"Display name: %s\" body.displayName\n    printfn \"User ID: %d\" body.id\n    printfn \"Description: %s\" body.description\n})\n    .Wait()\n</code></pre> <pre><code>using System.Net.Http;\nusing System.Text.Json;\n\nconst int USER_ID = 1;\nvar client = new HttpClient();\nvar response = await client.GetAsync($\"https://users.roblox.com/v1/users/{USER_ID}\");\n// Can also deserialize to a named type instead of dynamic to access the fields directly\ndynamic body = JsonSerializer.Deserialize&lt;dynamic&gt;(\n    await response.Content.ReadAsStringAsync()\n);\n\nConsole.WriteLine($\"Username: {body.GetProperty(\"name\")}\");\nConsole.WriteLine($\"Display name: {body.GetProperty(\"displayName\")}\");\nConsole.WriteLine($\"User ID: {body.GetProperty(\"id\")}\");\nConsole.WriteLine($\"Description: {body.GetProperty(\"description\")}\");\n</code></pre> <p>If your runtime doesn't support native fetch, like for example pre-v21 Node.js, you may need to install a package like node-fetch. <pre><code>const USER_ID = 1;\nconst response = await fetch(`https://users.roblox.com/v1/users/${USER_ID}`);\nconst body = await response.json();\n\nconsole.log(`Username: ${body[\"name\"]}`);\nconsole.log(`Display name: ${body[\"displayName\"]}`);\nconsole.log(`User ID: ${body[\"id\"]}`);\nconsole.log(`Description: ${body[\"description\"]}`);\n</code></pre></p>"}]}